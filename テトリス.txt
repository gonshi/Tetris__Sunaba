include("部品.txt");
 
マス目列=allocate(252);
マス目列を初期化する(マス目列);
マス目列を描く(マス目列);
 
ブロックx = 6;
ブロックy = 0;		//落ちてくるブロックの最初の位置
落下カウント= 0;	//落下スピードを調整
前の移動 = 0;	
ブロックの形 = 1;	//ブロックの形のパターンを整数値でおく
ブロックの向き = 1;	//ブロックの向きのパターンを整数値でおく
回転フラグ = 0;		//回転キー(↑)がおしっぱなしにされた際、
			//	連続して回転させないためのフラグ
新ブロック = 1;		//次に落ちてくるブロックの種類。コンピュータのクロックを利用して
			//	1〜7の整数値を変化させる
color = 000001;		//落ちてくるブロックの点滅を表現するための数値
ストック = 0;		//ホールドされているブロックの種類
ストックフラグ = 0;	//ホールドキー(スペース)が押しっぱなしにされた際、
			//	連続してホールドを行わないようにするためのフラグ
ゲームオーバー= 0;	//1になればゲームオーバー
 
while ( ゲームオーバー== 0 ){
	今の移動= 移動を取る();
	//新しい座標を用意
	新ブロックx = ブロックx;
	新ブロックy = ブロックy;
	
	新ブロック = 新ブロック　+ 1;
	if(新ブロック == 8){
		新ブロック　= 1;
	}
 
	//色を変化させる
	color = color * 3;
	if(color>999999){
		color = color - 999999;
	}
 
	//落下
	落下カウント= 落下カウント+ 1;
	if ( 落下カウント== 5 ){
		新ブロックy = 新ブロックy + 1;
		落下カウント= 0;
	}
	//移動後の座標を計算
	if ( 今の移動!= 前の移動){
		新ブロックx = 新ブロックx + 今の移動;
	}
 
	//ブロックの回転
	if((memory[50013]!=0) * (回転フラグ == 0)){		//memory[50013]は上キー
		ブロックの向き = ブロックの向き + 1;
		if(ブロックの向き == 5){
			ブロックの向き = 1;
		}
		//回転して壁にぶつかるならもとに戻す
		if(マス目を得る( マス目列, 新ブロックx, 新ブロックy , ブロックの形 , ブロックの向き ) == 1 ){
			ブロックの向き = ブロックの向き - 1;
			if(ブロックの向き == 0){
				ブロックの向き = 4;
			}
		}
		回転フラグ = 1;
	}
 
	if(memory[50013]==0){
		回転フラグ = 0;
	}
 
 
	//ストック
	if((memory[50017]!=0) * (ストックフラグ == 0)){
		if(ストック!=0){
			tmp = ブロックの形;
			ブロックの形 = ストック;
			ストック = tmp;
			ブロックx = 6;
			ブロックy = 0;
			新ブロックx = ブロックx;
			新ブロックy = ブロックy;
			ブロックの向き = 1;
			//もしこれがすでに埋まっているならゲームオーバー
			if ( マス目を得る( マス目列, ブロックx, ブロックy , ブロックの形 , ブロックの向き ) == 1 ){
				ゲームオーバー= 1;
			}
		}
		if(ストック==0){
			ストック = ブロックの形;
			ブロックの形 = 新ブロック;
			ブロックx = 6;
			ブロックy = 0;
			新ブロックx = ブロックx;
			新ブロックy = ブロックy;
			ブロックの向き = 1;
			//もしこれがすでに埋まっているならゲームオーバー
			if ( マス目を得る( マス目列, ブロックx, ブロックy , ブロックの形 , ブロックの向き ) == 1 ){
				ゲームオーバー= 1;
			}
		}
		ストックフラグ = 1;
	}
 
	if(memory[50017]==0){
		ストックフラグ = 0;
	}
 
	//詰まってるなら固定して新しいブロックを作る
	if ( マス目を得る( マス目列, 新ブロックx, 新ブロックy , ブロックの形 , ブロックの向き ) == 1 ){
		//落ちた時だけ、
		if ( ( 新ブロックy != ブロックy ) * ( 新ブロックx == ブロックx ) ){
			//マス目を詰める
			マス目を詰める( マス目列, ブロックx, ブロックy , ブロックの形 , ブロックの向き);
			消す( マス目列);
			ブロックの形 = 新ブロック;
			ブロックの向き = 1;
			//動くブロックを(6,0) へ
			ブロックx = 6;
			ブロックy = 0;
			//もしこれがすでに埋まっているならゲームオーバー
			if ( マス目を得る( マス目列, ブロックx, ブロックy , ブロックの形 , ブロックの向き ) == 1 ){
				ゲームオーバー= 1;
			}
		}
	}
	
	//詰まってないなら新しいのにする。
	if ( マス目を得る( マス目列, 新ブロックx, 新ブロックy , ブロックの形 , ブロックの向き ) == 0 ){
		ブロックx = 新ブロックx;
		ブロックy = 新ブロックy;
	}
	描く( マス目列, ブロックx, ブロックy , ブロックの形 , ブロックの向き ,color , ストック);
	前の移動= 今の移動;
}